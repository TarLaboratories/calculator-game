package com.calcgame.main;

import com.calcgame.main.buttons.Properties;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.python.core.PyComplex;
import org.python.core.PyObject;
import org.python.util.PythonInterpreter;
import com.calcgame.main.buttons.*;

import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;
import java.util.List;

/**
 * Represents the state of the game at all times.
 * Starts the game when constructed.
 */
public class GameState {
    /**
     * The logger used in this class
     */
    private static final Logger LOGGER = LogManager.getLogger();

    /**
     * The object used to generate random numbers, and the initial random seed
     */
    protected Random random = new Random();

    /**
     * A list of all random numbers in the order they were generated, used for undoing operations involving randomness
     */
    protected List<Integer> random_sequence = new ArrayList<>();

    /**
     * The index in {@link GameState#random_sequence} of the last random number generated by the selected action
     */
    protected int cur_random_i = 0;

    /**
     * All registered types of buttons.
     * The key is the type id, value is a {@link CalcButton} that was initialised without arguments,
     * and as such can only be used to create other buttons.
     */
    protected Map<String, CalcButton> button_types = Map.of("text", new TextButton(), "func", new FuncButton());

    /**
     * All loaded mod files, where the first key is the mod id, the second key is the file name
     */
    protected Map<String, Map<String, String>> mod_files = new HashMap<>();

    /**
     * All registered buttons.
     */
    protected List<CalcButton> all_buttons = new ArrayList<>();

    /**
     * A map, where the key is the button id, and the value is the {@link CalcButton} object representing the button
     */
    protected Map<String, CalcButton> button_lookup = new HashMap<>();

    /**
     * A list of all buttons that can appear in the shop
     */
    protected List<CalcButton> sellable_buttons = new ArrayList<>();

    /**
     * A collection of all buttons currently on the calculator, including system buttons (e.g. '=')
     */
    protected ButtonCollection buttons;

    /**
     * The shop reroll button
     */
    protected ShopRerollButton reroll_button;

    /**
     * The next round button, that appears below the shop
     */
    protected NextRoundButton next_round_button;

    /**
     * The undo button
     */
    protected UndoButton undo_button;

    /**
     * The redo button
     */
    protected RedoButton redo_button;

    /**
     * The number that the player has to reach to end the current round.
     * Is set to a random number in the range of {@code [0, 100)} at start of round.
     */
    protected PyComplex goal;

    /**
     * The amount of slots for normal buttons in the shop
     */
    protected int shop_slots = 6;

    /**
     * The amount of slots for infinity buttons in the shop
     */
    protected int infinity_shop_slots = 1;

    /**
     * The text currently displayed on the calculator screen, does not have to be a valid formula
     */
    protected String screen;

    /**
     * The amount of money the player currently has
     */
    protected PyComplex money = new PyComplex(0);

    /**
     * If the shop is currently visible
     */
    protected boolean inShop = false;

    /**
     * The collection of all buttons in the shop, may be {@code null} if {@link GameState#inShop} is {@code false}
     */
    protected ButtonCollection shop;

    /**
     * The number of the current round
     */
    protected long current_round = 0;

    /**
     * The type of rendering currently used (windowed, console, etc.)
     */
    protected RenderType renderType;

    /**
     * The window in which everything is rendered
     */
    protected Frame window;

    /**
     * A panel, which has bounds the same as the window.
     * Anything in this panel will be rendered above anything not in this panel.
     */
    protected Panel overlay;

    /**
     * The label that is rendered at the top of the calculator
     */
    protected Label calc_screen;

    /**
     * The label, where the current goal is rendered
     */
    protected Label goal_label;

    /**
     * The label, where the current money is rendered
     */
    protected Label money_label;

    /**
     * A list of all labels, of which the tooltip consists.
     * Usually has a constant size of 64
     */
    protected List<Label> tooltip_labels;

    /**
     * The panel that provides the tooltip background
     */
    protected Panel tooltip_bg;

    /**
     * The undo stack, consists of all actions done using {@link GameState#doAction(Action)}
     * @see GameState#undo()
     * @see GameState#redo()
     */
    protected List<Action> undo_stack = new ArrayList<>();

    /**
     * The action to be appended to the next action done using {@link GameState#doAction(Action)}
     * @see GameState#appendToNextAction(Action)
     */
    protected Action temp_action = Action.forUndo(() -> {}, "appendToNext");

    /**
     * The index of the action currently selected in the {@link GameState#undo_stack}
     */
    protected int cur_undo_stack_i = -1;

    /**
     * A map, where the keys are event ids, and the values are the event objects.
     * @see Events
     */
    protected Map<String, Event> events;

    /**
     * The random seed, generated when this object is constructed.
     */
    protected long seed;

    /**
     * Constructs a new GameState and starts the game.
     */
    public GameState() {
        LOGGER.info("Creating a new game state");
        seed = random.nextLong();
        random.setSeed(seed);
        events = new HashMap<>(Map.of(
                Events.ADD, new Event("buttonAdd"),
                Events.CLICK, new Event("buttonClick"),
                Events.ROUND_END, new Event("roundEnd"),
                Events.ROUND_START, new Event("roundStart"),
                Events.REROLL, new Event("shopReroll"),
                Events.BUY, new Event("buy"),
                Events.KEY_PRESS, new Event("keyPress"),
                Events.MOUSE_CLICK, new Event("mouseClick")
        ));
        prepareRender();
        loadMods();
        addSystemButtons();
        prepareCalculatorRender();
        nextRound();
        GameLoop loop = new GameLoop(this);
        loop.loop();
    }

    /**
     * Adds vital buttons to the game (e.g. '=', 'UNDO', 'REDO', 'Reroll', etc.)
     */
    public void addSystemButtons() {
        all_buttons.add(new CalculateButton());
        buttons.add(all_buttons.getLast(), Properties.count(1.).infinity());
        button_lookup.put("=", all_buttons.getLast());
        reroll_button = new ShopRerollButton();
        next_round_button = new NextRoundButton();
        button_lookup.put(reroll_button.getString(), reroll_button);
        button_lookup.put(next_round_button.getString(), next_round_button);
        undo_button = new UndoButton();
        redo_button = new RedoButton();
        buttons.add(undo_button, Properties.count(1).infinity());
        buttons.add(redo_button, Properties.count(1).infinity());
    }

    /**
     * Prepares the window for rendering, creating all necessary frame and label objects
     */
    public void prepareRender() {
        renderType = RenderType.WINDOW;
        window = new Frame();
        window.setTitle("Calculator Game");
        window.setSize(600, 600);
        window.setLocation(100, 100);
        window.setLayout(null);
        window.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                LOGGER.info("Exiting...");
                window.dispose();
            }
        });
        window.setVisible(true);
        overlay = new Panel();
        overlay.setLayout(null);
        overlay.setSize(600, 600);
        overlay.setVisible(false);
        tooltip_labels = new ArrayList<>();
        for (int i = 0; i < 64; i++) {
            Label tooltip_label = new Label();
            tooltip_label.setBackground(Color.GRAY);
            tooltip_label.setVisible(false);
            window.add(tooltip_label);
            tooltip_labels.add(tooltip_label);
        }
        tooltip_bg = new Panel();
        tooltip_bg.setBackground(Color.GRAY);
        tooltip_bg.setVisible(false);
        window.add(tooltip_bg);
        buttons = new ButtonCollection(getCalculatorDimensions(), this);
    }

    /**
     * Loads all mods from the mod folder (./mods), and starting buttons from them
     */
    public void loadMods() {
        LOGGER.info("Loading mods...");
        File mods = new File("mods");
        if (!mods.isDirectory()) LOGGER.warn("Invalid mods directory ({})!", mods.getAbsolutePath());
        String[] mod_list = mods.list();
        if (mod_list != null) {
            for (String mod_id : mod_list) {
                LOGGER.info("Loading mod '{}'", mod_id);
                File mod_folder = new File(mods, mod_id);
                mod_files.put(mod_id, new HashMap<>());
                for (File file : Objects.requireNonNull(mod_folder.listFiles())) {
                    try {
                        LOGGER.info("Loading file '{}' from mod '{}'", file.getName(), mod_id);
                        Scanner scanner = new Scanner(file);
                        mod_files.get(mod_id).put(file.getName(), scanner.useDelimiter("$").next());
                    } catch (FileNotFoundException ignored) {}
                }
                File config = new File(mod_folder, "config.json");
                if (config.exists() && config.isFile()) loadConfig(config, mod_id);
            }
            all_buttons.forEach((b) -> button_lookup.put(b.getString(), b));
            sellable_buttons.addAll(all_buttons);
            for (String mod_id : mod_list) {
                File mod_folder = new File(mods, mod_id);
                File config = new File(mod_folder, "config.json");
                if (config.exists() && config.isFile()) loadStartingButtons(config, mod_id);
            }
        }
        LOGGER.trace("Loaded buttons: {}", button_lookup.keySet());
    }

    /**
     * Prepares the calculator for rendering by creating all necessary label objects
     */
    public void prepareCalculatorRender() {
        calc_screen = new Label();
        Rectangle pos = getScreenDimensions();
        pos.x = (int) Math.round(pos.getCenterX());
        pos.width = pos.width/2;
        calc_screen.setBounds(pos);
        calc_screen.setAlignment(Label.RIGHT);
        goal_label = new Label();
        pos = getScreenDimensions();
        pos.width = pos.width/2;
        pos.x = getButtonPadding();
        goal_label.setBounds(pos);
        goal_label.setAlignment(Label.LEFT);
        money_label = new Label("$" + numToString(money));
        pos = getScreenDimensions();
        pos.x = getShopDimensions().x;
        money_label.setBounds(pos);
        window.add(overlay);
        window.add(calc_screen);
        window.add(goal_label);
        window.add(money_label);
    }

    /**
     * Loads all mod configuration, except starting buttons, from a file
     * @param file the file to load from
     * @param mod_id the id of the mod that supplied the file
     */
    public void loadConfig(File file, String mod_id) {
        LOGGER.info("Loading config file from mod '{}'", mod_id);
        try {
            Scanner scanner = new Scanner(file);
            String s = scanner.useDelimiter("$").next();
            JSONObject obj = new JSONObject(s);
            if (!obj.isNull("operations")) {
                JSONObject ops = obj.getJSONObject("operations");
                for (String op : ops.keySet()) {
                    JSONObject op_json = ops.getJSONObject(op);
                    String op_code = op_json.getString("function");
                    int priority = op_json.isNull("priority") ? 1 : op_json.getInt("priority");
                    try (PythonInterpreter py = new PythonInterpreter()) {
                        try {
                            py.exec(op_code);
                            PyObject op_func = py.get("f");
                            if (op_func == null || !op_func.isCallable()) throw new RuntimeException();
                            CalculateButton.addOperation(op, priority, (a, b) -> {
                                py.set("__a", a);
                                py.set("__b", b);
                                return op_func.__call__(py.get("__a"), py.get("__b")).__complex__();
                            });
                        } catch (RuntimeException ignored) {
                            CalculateButton.addOperation(op, priority, (a, b) -> {
                                py.set("a", a);
                                py.set("b", b);
                                return py.eval(op_code).__complex__();
                            });
                        }
                    }
                }
            }
            if (!obj.isNull("buttons")) {
                JSONObject button_config = obj.getJSONObject("buttons");
                for (Iterator<String> it = button_config.keys(); it.hasNext(); ) {
                    String button_type = it.next();
                    if (button_types.containsKey(button_type)) {
                        JSONArray arr = button_config.getJSONArray(button_type);
                        for (int i = 0; i < arr.length(); i++) {
                            if (arr.get(i) instanceof JSONArray args) {
                                List<String> str_args = new ArrayList<>();
                                for (Object o : args) {
                                    if (mod_files.get(mod_id).containsKey((String) o)) str_args.add(mod_files.get(mod_id).get(o));
                                    else str_args.add((String) o);
                                }
                                all_buttons.add(button_types.get(button_type).newButton(str_args, mod_id));
                            } else all_buttons.add(button_types.get(button_type).newButton(List.of(arr.getString(i)), mod_id));
                        }
                    } else LOGGER.warn("Unknown button type: {}", button_type);
                }
            }
            if (!obj.isNull("functions")) {
                JSONObject funcs = obj.getJSONObject("functions");
                for (Iterator<String> it = funcs.keys(); it.hasNext(); ) {
                    String func_name = it.next();
                    String f_code = funcs.getString(func_name);
                    try (PythonInterpreter py = new PythonInterpreter()) {
                        try {
                            py.exec(f_code);
                            PyObject op_func = py.get("f");
                            if (op_func == null || !op_func.isCallable()) throw new RuntimeException();
                            CalculateButton.addFunction(func_name, (x) -> {
                                py.set("__x", x);
                                return op_func.__call__(py.get("__x")).__complex__();
                            });
                        } catch (RuntimeException ignored) {
                            CalculateButton.addFunction(func_name, (x) -> {
                                py.set("x", x);
                                return py.eval(f_code).__complex__();
                            });
                        }
                    }
                }
            }
            LOGGER.info("Loading mod '{}' completed", mod_id);
        } catch (FileNotFoundException | JSONException e) {
            LOGGER.warn("Unable to load mod config from file '{}': {}", file.getName(), e);
        }
    }

    /**
     * Loads the starting buttons from a mod config file
     * @param file the file to load from
     * @param mod_id the mod id of the mod that supplied this file
     */
    public void loadStartingButtons(File file, String mod_id) {
        try {
            LOGGER.info("Loading starting buttons from mod '{}'", mod_id);
            Scanner scanner = new Scanner(file);
            String s = scanner.useDelimiter("$").next();
            JSONObject obj = new JSONObject(s);
            if (!obj.isNull("starting_buttons")) {
                JSONArray arr = obj.getJSONArray("starting_buttons");
                arr.forEach((o) -> {
                    if (button_lookup.containsKey((String) o))
                        buttons.add(button_lookup.get((String) o), new PyComplex(2));
                    else if (button_lookup.containsKey("%s:%s".formatted(mod_id, o)))
                        buttons.add(button_lookup.get("%s:%s".formatted(mod_id, o)), new PyComplex(2));
                    else LOGGER.warn("Mod {} contains an unknown starting button {}, ignoring", mod_id, ((String) o).contains(":") ? o : "%s:%s".formatted(mod_id, o));
                });
            }
            LOGGER.info("Loading starting buttons from mod '{}' completed", mod_id);
        } catch (FileNotFoundException | JSONException e) {
            LOGGER.warn("Unable to load starting buttons from mod config file '{}': {}", file.getName(), e);
        }
    }

    /**
     * Refreshes the shop, or creates it if it didn't exist.
     * Appends the (undoable) refresh action to the last action (being) executed.
     */
    public void refreshShop() {
        JSONObject old_shop;
        if (shop != null) {
            old_shop = shop.toJSON();
            shop.destroy();
        } else {
            old_shop = null;
        }
        appendToLastAction(new Action("Reroll") {
            @Override
            protected void redoInternal() {
                LOGGER.info("Refreshing shop");
                shop = new ButtonCollection(getShopDimensions(), GameState.this);
                for (int i = 0; i < shop_slots; i++) {
                    CalcButton button = getRandomButton();
                    shop.add(button, Properties.price(getPrice(button)));
                }
                for (int i = 0; i < infinity_shop_slots; i++) {
                    CalcButton button = getRandomButton();
                    shop.add(button, Properties.price(getPrice(button).__mul__(new PyComplex(5.)).__complex__()).infinity());
                }
                shop.add(reroll_button, Properties.price(1.));
                shop.add(next_round_button, Properties.price(0.));
            }

            @Override
            protected void undoInternal() {
                LOGGER.info("Unrefreshing shop");
                if (shop != null) shop.destroy();
                if (old_shop != null) {
                    shop = ButtonCollection.fromJSON(old_shop, GameState.this);
                    shop.render();
                }
            }

            @Override
            public boolean undoable() {
                return true;
            }
        }).redo();
        getEvent(Events.REROLL).emit(new ActionContext(this, null, null, shop, getScreen(), LOGGER));
    }

    /**
     * Starts the next round, closing the shop and increasing the round counter.
     * Generates one action, that is not undoable
     */
    public void nextRound() {
        inShop = false;
        setGoal(new PyComplex(random.nextInt(100)));
        setScreen(Integer.toString(random.nextInt(100)));
        if (shop != null) shop.destroy();
        current_round++;
        doAction(Action.forFunction(() -> {}, "nextRound"));
        getEvent(Events.ROUND_START).emit(new ActionContext(this, null, null, buttons, getScreen(), LOGGER));
    }

    /**
     * Ends the current round, and displays the shop.
     * Generates one action, that is not undoable.
     */
    public void endRound() {
        LOGGER.info("Round #{} ended", current_round);
        appendToLastAction(Action.forFunction(() -> {}, "endRound")); //block undo further than round end
        inShop = true;
        addMoney(Math.min(((int) getMoney().real)/5, 5));
        addMoney(1.);
        getEvent(Events.ROUND_END).emit(new ActionContext(this, null, null, buttons, getScreen(), LOGGER));
        refreshShop();
    }

    /**
     * Adds the specified amount to the player's money
     * @param x the amount to add
     */
    public void addMoney(int x) {
        addMoney((double) x);
    }

    /**
     * Adds the specified amount to the player's money
     * @param x the amount to add
     */
    public void addMoney(Double x) {
        setMoney(new PyComplex(getMoney().real + x, getMoney().imag));
    }

    /**
     * Adds the specified amount to the player's money
     * @param x the amount to add
     */
    public void addMoney(PyComplex x) {
        setMoney(getMoney().__add__(x).__complex__());
    }

    /**
     * Returns a random sellable button
     * @return a random, currently sellable button
     */
    public CalcButton getRandomButton() {
        return sellable_buttons.get(randint(0, sellable_buttons.size()));
    }

    /**
     * Returns the price of this button
     * @param button the button to get the price of
     * @return the price of this button, if it were in the shop
     */
    public PyComplex getPrice(CalcButton button) {
        return button.getPrice(this);
    }

    /**
     * Returns the distance between buttons
     * @return the distance between buttons (in px)
     */
    public int getButtonPadding() {
        return switch (renderType) {
            case WINDOW -> 10;
            case CONSOLE -> 1;
        };
    }

    /**
     * Returns the bounds of the shop
     * @return the bounds of the shop
     */
    public Rectangle getShopDimensions() {
        return switch (renderType) {
            case WINDOW -> new Rectangle(window.getWidth() - 350, getCalculatorDimensions().y, 200, 600);
            case CONSOLE -> new Rectangle(8, 8);
        };
    }

    /**
     * Returns the bounds of the calculator
     * @return the bounds of the calculator
     */
    public Rectangle getCalculatorDimensions() {
        return switch (renderType) {
            case WINDOW -> new Rectangle(0, window.getInsets().top + 20, 300, 600);
            case CONSOLE -> new Rectangle(8, 8);
        };
    }

    /**
     * Returns the bounds of the calculator screen
     * @return the bounds of the calculator screen
     */
    public Rectangle getScreenDimensions() {
        return switch (renderType) {
            case WINDOW -> new Rectangle(0, window.getInsets().top, buttons.getWidth(), 20);
            case CONSOLE -> new Rectangle(8, 1);
        };
    }

    /**
     * Returns the string currently displayed on the calculator screen
     * @return the string currently displayed on the calculator screen
     */
    public String getScreen() {
        return screen;
    }

    /**
     * Sets the string on the calculator screen to the specified string
     * @param s the string to display, does not have to be a valid mathematical expression
     */
    public void setScreen(String s) {
        if (s.startsWith("0") && s.length() > 1) s = s.substring(1);
        if (s.endsWith("+0j)") && s.startsWith("(")) s = s.substring(1, s.length() - 4);
        screen = s;
        calc_screen.setText(s);
        try {
            if (!inShop && Objects.equals(screen, numToString(getGoal()))) endRound();
        } catch (NumberFormatException ignored) {}
    }

    /**
     * Sets the amount of money the player has
     * @param money the number to set the money to
     */
    public void setMoney(PyComplex money) {
        this.money = money;
        money_label.setText("$" + numToString(money));
    }

    /**
     * Returns the amount of money the player currently has
     * @return the amount of money the player currently has
     */
    public PyComplex getMoney() {
        return money;
    }

    /**
     * Set the number, that the player is required to reach to end this round
     * @param goal the number to set the goal to
     */
    public void setGoal(PyComplex goal) {
        this.goal = goal;
        goal_label.setText("Goal: %s".formatted(numToString(goal)));
    }

    /**
     * Reduce the player's money by the specified amount
     * @param price the amount by which to reduce the player's money
     */
    public void subMoney(PyComplex price) {
        this.setMoney(this.getMoney().__sub__(price).__complex__());
    }

    /**
     * Returns a human-readable string representing this number. This should be preferred over {@link PyComplex#toString()}
     * @param x the number to stringify
     * @return A human-readable string representing this number.
     */
    public String numToString(PyComplex x) {
        if (x.real == 0 && x.imag == 0) return "0";
        if (x.__cmp__(PyComplex.Inf) == 0) return "Infinity";
        if (Math.abs(x.imag) < 1e-6) return numToString(x.real);
        else return "%s+%si".formatted(numToString(x.real), numToString(x.imag));
    }

    /**
     * Returns a human-readable string representing this number. This should be preferred over {@link Double#toString()}
     * @param x the number to stringify
     * @return A human-readable string representing this number.
     */
    public String numToString(double x) {
        if (Math.abs(x) > 5e10) return "%.1e".formatted(x);
        if (Math.abs(x - Math.round(x)) < 1e-6) return "%d".formatted(Math.round(x));
        else return "%.3f".formatted(x);
    }

    /**
     * Returns the number that the player is required to reach to end this round
     * @return the number that the player is required to reach to end this round
     */
    public PyComplex getGoal() {
        return goal;
    }

    /**
     * Returns the currently used {@link RenderType}
     * @return the {@link RenderType} currently used
     */
    public RenderType getRenderType() {
        return renderType;
    }

    /**
     * Returns a {@link ButtonCollection} of buttons currently on the calculator
     * @return a {@link ButtonCollection} of buttons currently on the calculator
     */
    public ButtonCollection getCurrentButtons() {
        return buttons;
    }

    /**
     * Returns a list of all buttons registered
     * @return a list of all buttons registered
     */
    @ForMods
    public List<CalcButton> getAllButtons() {
        return all_buttons;
    }

    /**
     * Returns the Frame object, inside which everything is rendered
     * @return the Frame object, inside which everything is rendered
     */
    public Frame getWindow() {
        return window;
    }

    /**
     * Returns the list of buttons that can appear in the shop
     * @return the list of buttons that can appear in the shop
     */
    public List<CalcButton> getSellableButtons() {
        return sellable_buttons;
    }

    /**
     * Returns a button that was registered under the specified id
     * @param name the button id
     * @return a button that was registered under the specified id
     */
    public CalcButton getButton(String name) {
        return button_lookup.get(name);
    }

    /**
     * Returns a random element from the specified list.
     * @param in the list from which to choose
     * @return the randomly chosen element
     */
    @ForMods
    public Object randomChoice(List<Object> in) {
        return in.get(randint(0, in.size()));
    }

    /**
     * Returns a random number between {@code min} (inclusive) and {@code max} (exclusive)
     * @param min the minimum number (inclusive)
     * @param max the maximum number (exclusive)
     * @return a random number in the range {@code [min, max)}
     */
    public int randint(int min, int max) {
        if (cur_random_i == random_sequence.size()) {
            random_sequence.add(random.nextInt(min, max));
            cur_random_i++;
            return random_sequence.getLast();
        } else {
            cur_random_i++;
            return random_sequence.get(cur_random_i - 1);
        }
    }

    /**
     * Registers a Python function to be executed at start of round.
     * @param id The id to register the function under. It's only effect is to be used in {@link GameState#removeOnRoundStart(String)} later.
     * @param f The Python function to register. Must be a callable python object.
     */
    @ForMods
    public void onRoundStart(String id, PyObject f) {
        getEvent(Events.ROUND_START).addListener(Action.forFunction(f::__call__, "py_%s_listener".formatted(id)), id);
    }

    /**
     * Removes the function that was previously registered using {@link GameState#onRoundStart(String, PyObject)}
     * @param id the id of the function to remove
     */
    @ForMods
    public void removeOnRoundStart(String id) {
        getEvent(Events.ROUND_START).removeListener(id);
    }

    /**
     * Has a {@code a/b} chance to return {@code true}. Uses {@link GameState#randint(int, int)}
     * @param a the quantifier
     * @param b the divisor
     * @return {@code true} with a chance of {@code a/b}, {@code false} otherwise
     */
    @ForMods
    public boolean chance(int a, int b) {
        return this.randint(0, b) < a;
    }

    /**
     * Renders a tooltip with the specified contents at the specified position
     * @param text The contents of the tooltip to render. Will be line-wrapped to fit into the specified bounds.
     * @param bounds the position and size of the tooltip to render
     */
    public void setTooltip(String text, Rectangle bounds) {
        FontMetrics m = tooltip_labels.getFirst().getFontMetrics(tooltip_labels.getFirst().getFont());
        StringBuilder tmp_line = new StringBuilder();
        Scanner idk = new Scanner(text);
        int cur_label = 0;
        Rectangle cur_bounds = new Rectangle(bounds), bg_bounds = new Rectangle(bounds);
        cur_bounds.height = m.getHeight();
        while (idk.hasNext()) {
            String next = idk.next();
            if (m.stringWidth(tmp_line + next + " ") < bounds.width) tmp_line.append(next).append(" ");
            else {
                Label tooltip_label = tooltip_labels.get(cur_label);
                tooltip_label.setText(tmp_line.toString());
                tooltip_label.setBounds(cur_bounds);
                tooltip_label.setVisible(true);
                tmp_line = new StringBuilder(next + " ");
                cur_bounds.y += cur_bounds.height + 1;
                bg_bounds.height = Math.max(bg_bounds.height, cur_bounds.y + cur_bounds.height - bg_bounds.y);
                cur_label++;
            }
        }
        Label tooltip_label = tooltip_labels.get(cur_label);
        tooltip_label.setText(tmp_line.toString());
        tooltip_label.setBounds(cur_bounds);
        tooltip_label.setVisible(true);
        tooltip_bg.setBounds(bg_bounds);
        tooltip_bg.setVisible(true);
    }

    /**
     * Removes any tooltip currently rendered
     */
    public void removeTooltip() {
        tooltip_bg.setVisible(false);
        tooltip_labels.forEach((l) -> l.setVisible(false));
    }

    /**
     * Invokes {@link Action#undoInternal()} of the action currently selected in the undo stack, and moves the selection
     * to the previous action.
     */
    public void undo() {
        if (cur_undo_stack_i >= 0 && undo_stack.get(cur_undo_stack_i).undoable()) {
            undo_stack.get(cur_undo_stack_i).undo();
            cur_undo_stack_i--;
        } else if (cur_undo_stack_i == -1) LOGGER.debug("Cannot undo action, as there is nothing left to undo");
        else LOGGER.debug("Cannot undo action {}, as it is marked as not undoable", undo_stack.get(cur_undo_stack_i).name);
    }

    /**
     * Moves the selection to the next action in the undo stack, and invokes {@link Action#redo()} of the newly selected action.
     */
    public void redo() {
        if (cur_undo_stack_i + 1 < undo_stack.size()) {
            cur_undo_stack_i++;
            undo_stack.get(cur_undo_stack_i).redo();
        }
    }

    /**
     * Appends the specified action to the undo stack (at the position after the currently selected action), then executes it. Also appends a
     * reset of this {@code GameState} random state (to it's state before the action is executed) to the undo function
     * @param action the action to execute and save to the undo stack
     */
    public void doAction(Action action) {
        LOGGER.trace("Doing action");
        int old_random_i = cur_random_i;
        action = action.andThen(temp_action).andThen(Action.forUndo(() -> {
            if (cur_random_i == old_random_i) return;
            LOGGER.debug("Undoing changes to random: {} -> {}", cur_random_i, old_random_i);
            cur_random_i = old_random_i;
        }, "randUndo"));
        temp_action = Action.forUndo(() -> {}, "appendToNext");
        if (undo_stack.size() > cur_undo_stack_i + 1) undo_stack.removeLast();
        cur_undo_stack_i++;
        undo_stack.add(action);
        action.redo();
        if (old_random_i != cur_random_i) LOGGER.debug("Random changed: {} -> {}", old_random_i, cur_random_i);
    }

    /**
     * Appends the specified {@code Action} to the last action executed (or currently being executed)
     * by the means of {@link Action#andThen(Action)}. It will not be executed, unless it is undone and then redone.
     * The returned action is safe to {@link Action#redo()} without invoking {@link GameState#doAction(Action)}
     * @param action the {@code Action} to append
     * @return the input action
     */
    public Action appendToLastAction(Action action) {
        if (undo_stack.isEmpty()) {
            LOGGER.warn("Appending to last action when no actions exist!");
            return action;
        }
        undo_stack.set(cur_undo_stack_i, undo_stack.get(cur_undo_stack_i).andThen(action));
        if (!action.name.startsWith("APPENDED/")) action.name = "APPENDED/" + action.name;
        return action;
    }

    /**
     * When {@link GameState#doAction(Action)} is invoked next time, the specified {@code Action}
     * will be appended to the {@code doAction parameter} (by the means of {@link Action#andThen(Action)}), before it is executed.
     * @param action the {@code Action} to append
     */
    @ForMods
    public void appendToNextAction(Action action) {
        temp_action = temp_action.andThen(action);
    }

    /**
     * Returns the context of the last executed {@code Action}
     * @return the context of the last executed {@code Action}
     */
    @ForMods
    public ActionContext getCurrentActionContext() {
        if (undo_stack.isEmpty()) return null;
        return undo_stack.get(cur_undo_stack_i).getContext();
    }

    /**
     * Returns the event with the specified name.
     * @param name the name of the event
     * @return the event, or {@code null} if it does not exist
     * @see Events
     */
    public Event getEvent(String name) {
        return events.get(name);
    }

    /**
     * Represents the type of rendering used (in console (not yet implemented) or windowed)
     */
    public enum RenderType {
        /**
         * Represents rendering everything in the console (not yet implemented)
         */
        CONSOLE,
        /**
         * Represents rendering everything in a window
         */
        WINDOW
    }
}
